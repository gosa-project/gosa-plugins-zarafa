#!/usr/bin/perl
#===============================================================================
#
#         FILE:  gosa-server
#
#        USAGE:  gosa-si-client
#
#  DESCRIPTION:
#
#      OPTIONS:  ---
# REQUIREMENTS:  libnetaddr-ip-perl
#         BUGS:  ---
#        NOTES:
#       AUTHOR:   (Andreas Rettenberger), <rettenberger@gonicus.de>
#      COMPANY:
#      VERSION:  1.0
#      CREATED:  12.09.2007 08:54:41 CEST
#     REVISION:  ---
#===============================================================================

use strict;
use warnings;
use utf8;
use Getopt::Long;
use Config::IniFiles;
use POSIX;
use Time::HiRes qw( gettimeofday );

use POE qw(Component::Server::TCP Wheel::FollowTail);
use IO::Socket::INET;
use NetAddr::IP;
use Data::Dumper;
use Crypt::Rijndael;
use GOSA::GosaSupportDaemon;
use Digest::MD5  qw(md5_hex md5 md5_base64);
use MIME::Base64;
use XML::Simple;
use Net::DNS;
use File::Basename;

my $event_dir = "/usr/lib/gosa-si/client/events";
use lib "/usr/lib/gosa-si/client/events";

my ($cfg_file, %cfg_defaults, $foreground, $verbose, $pid_file, $opts_file, $procid, $pid, $log_file, $fai_logpath);
my ($server_ip, $server_port, $server_key, $server_timeout, $server_domain, $server_key_lifetime);
my ($client_ip, $client_port, $client_mac_address, $ldap_enabled, $ldap_config, $pam_config, $nss_config);
my $xml;
my $default_server_key;
my $event_hash;
my @servers;
my $gotoHardwareChecksum;
my $gosa_si_client_fifo;
my %files_to_watch;
$verbose= 1;

# globalise variables which are used in imported events
our $cfg_file;
our $server_address;
our $client_address;
our $server_key;

# default variables
our $REGISTERED = 0;

# path to fifo for non-gosa-si-client messages to gosa-si-server
$gosa_si_client_fifo = "/var/run/gosa-si-client.socket";
%files_to_watch = (fifo => $gosa_si_client_fifo); 

# in function register_at_gosa_si_server, after which period of seconds a new registration should be tried if a registration was 
# not successful until now
my $delay_set_time = 5;
our $prg= basename($0);

%cfg_defaults = (
"general" =>
    {"log-file"           => [\$log_file, "/var/run/".$prg.".log"],
    "pid-file"            => [\$pid_file, "/var/run/".$prg.".pid"],
    "opts-file"            => [\$opts_file, "/var/run/".$prg.".opts"],
    },
"client" => 
    {"port"        => [\$client_port, "20083"],
     "ip"          => [\$client_ip, "0.0.0.0"],
     "mac-address" => [\$client_mac_address, "00:00:00:00:00:00"],
     "server-domain"       => [\$server_domain, ""],
     "ldap"               => [\$ldap_enabled, 1],
     "ldap-config"        => [\$ldap_config, "/etc/ldap/ldap.conf"],
     "pam-config"         => [\$pam_config, "/etc/pam_ldap.conf"],
     "nss-config"         => [\$nss_config, "/etc/libnss_ldap.conf"],
     "fai-logpath"         => [\$fai_logpath, "/var/log/fai/fai.log"],
    },
"server" => {
    "ip"          => [\$server_ip, "127.0.0.1"],
    "port"         => [\$server_port, "20081"],
    "key"          => [\$server_key, ""],
    "timeout"      => [\$server_timeout, 10],
    "key-lifetime" => [\$server_key_lifetime, 600], 
    },

);


#=== FUNCTIONS = functions =====================================================

#===  FUNCTION  ================================================================
#         NAME: check_cmdline_param
#   PARAMETERS: 
#      RETURNS:  
#  DESCRIPTION: 
#===============================================================================
sub check_cmdline_param () {
    my $err_config;
    my $err_counter = 0;
	if(not defined($cfg_file)) {
		$cfg_file = "/etc/gosa-si/client.conf";
		if(! -r $cfg_file) {
			$err_config = "please specify a config file";
			$err_counter += 1;
		}
    }
    if( $err_counter > 0 ) {
        &usage( "", 1 );
        if( defined( $err_config)) { print STDERR "$err_config\n"}
        print STDERR "\n";
        exit( -1 );
    }
}


#===  FUNCTION  ================================================================
#         NAME:  read_configfile
#   PARAMETERS:  cfg_file - string - 
#      RETURNS:  
#  DESCRIPTION: 
#===============================================================================
sub read_configfile {
    my ($cfg_file, %cfg_defaults) = @_ ;
    my $cfg;
    if( defined( $cfg_file) && ( length($cfg_file) > 0 )) {
        if( -r $cfg_file ) {
            $cfg = Config::IniFiles->new( -file => $cfg_file );
        } else {
            print STDERR "Couldn't read config file!";
        }
    } else {
        $cfg = Config::IniFiles->new() ;
    }
    foreach my $section (keys %cfg_defaults) {
        foreach my $param (keys %{$cfg_defaults{ $section }}) {
            my $pinfo = $cfg_defaults{ $section }{ $param };
            ${@$pinfo[ 0 ]} = $cfg->val( $section, $param, @$pinfo[ 1 ] );
        }
    }
}


#===  FUNCTION  ================================================================
#         NAME: check_pid
#   PARAMETERS:
#      RETURNS:
#  DESCRIPTION:
#===============================================================================
sub check_pid {
    $pid = -1;
    # Check, if we are already running
    if( open(LOCK_FILE, "<$pid_file") ) {
        $pid = <LOCK_FILE>;
        if( defined $pid ) {
            chomp( $pid );
            if( -f "/proc/$pid/stat" ) {
                my($stat) = `cat /proc/$pid/stat` =~ m/$pid \((.+)\).*/;
                if( $0 eq $stat ) {
                    close( LOCK_FILE );
                    exit -1;
                }
            }
        }
        close( LOCK_FILE );
        unlink( $pid_file );
    }

    # create a syslog msg if it is not to possible to open PID file
    if (not sysopen(LOCK_FILE, $pid_file, O_WRONLY|O_CREAT|O_EXCL, 0644)) {
        my($msg) = "Couldn't obtain lockfile '$pid_file' ";
        if (open(LOCK_FILE, '<', $pid_file)
                && ($pid = <LOCK_FILE>))
        {
            chomp($pid);
            $msg .= "(PID $pid)\n";
        } else {
            $msg .= "(unable to read PID)\n";
        }
        if( ! ($foreground) ) {
            openlog( $0, "cons,pid", "daemon" );
            syslog( "warning", $msg );
            closelog();
        }
        else {
            print( STDERR " $msg " );
        }
        exit( -1 );
    }
}


sub sig_int_handler {
    my ($signal) = @_;

    daemon_log("shutting down gosa-si-server", 1);
    exit(1);
}
$SIG{INT} = \&sig_int_handler;


#===  FUNCTION  ================================================================
#         NAME:  logging
#   PARAMETERS:  level - string - default 'info' 
#                msg - string - 
#                facility - string - default 'LOG_DAEMON' 
#      RETURNS:  
#  DESCRIPTION: 
#===============================================================================
sub daemon_log {
    # log into log_file
    my( $msg, $level ) = @_;
    if(not defined $msg) { return }
    if(not defined $level) { $level = 1 }
    if(defined $log_file){
        open(LOG_HANDLE, ">>$log_file");
        if(not defined open( LOG_HANDLE, ">>$log_file" )) {
            print STDERR "cannot open $log_file: $!";
            return }
            chomp($msg);
            if($level <= $verbose){
                my ($seconds, $minutes, $hours, $monthday, $month,
                        $year, $weekday, $yearday, $sommertime) = localtime(time);
                $hours = $hours < 10 ? $hours = "0".$hours : $hours;
                $minutes = $minutes < 10 ? $minutes = "0".$minutes : $minutes;
                $seconds = $seconds < 10 ? $seconds = "0".$seconds : $seconds;
                my @monthnames = ("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
                $month = $monthnames[$month];
                $monthday = $monthday < 10 ? $monthday = "0".$monthday : $monthday;
                $year+=1900;

                my $log_msg = "$month $monthday $hours:$minutes:$seconds $prg $msg\n";
                print LOG_HANDLE $log_msg;
                if( $foreground ) { 
                    print STDERR $log_msg;
                }
            }
        close( LOG_HANDLE );
    }
#log into syslog
#    my ($msg, $level, $facility) = @_;
#    if(not defined $msg) {return}
#    if(not defined $level) {$level = "info"}
#    if(not defined $facility) {$facility = "LOG_DAEMON"}
#    openlog($0, "pid,cons,", $facility);
#    syslog($level, $msg);
#    closelog;
#    return;
}


#===  FUNCTION  ================================================================
#         NAME:  get_interfaces 
#   PARAMETERS:  none
#      RETURNS:  (list of interfaces) 
#  DESCRIPTION:  Uses proc fs (/proc/net/dev) to get list of interfaces.
#===============================================================================
sub get_interfaces {
    my @result;
    my $PROC_NET_DEV= ('/proc/net/dev');

    open(PROC_NET_DEV, "<$PROC_NET_DEV")
        or die "Could not open $PROC_NET_DEV";

    my @ifs = <PROC_NET_DEV>;

    close(PROC_NET_DEV);

    # Eat first two line
    shift @ifs;
    shift @ifs;

    chomp @ifs;
    foreach my $line(@ifs) {
        my $if= (split /:/, $line)[0];
        $if =~ s/^\s+//;
        push @result, $if;
    }

    return @result;
}

#===  FUNCTION  ================================================================
#         NAME:  get_mac 
#   PARAMETERS:  interface name (i.e. eth0)
#      RETURNS:  (mac address) 
#  DESCRIPTION:  Uses ioctl to get mac address directly from system.
#===============================================================================
sub get_mac {
	my $ifreq= shift;
	my $result;
	if ($ifreq && length($ifreq) > 0) { 
		if($ifreq eq "all") {
			if(defined($server_ip)) {
				$result = &get_local_mac_for_remote_ip($server_ip);
			} 
			elsif ($client_mac_address && length($client_mac_address) > 0 && !($client_mac_address eq "00:00:00:00:00:00")){
				$result = &client_mac_address;
			} 
			else {
				$result = "00:00:00:00:00:00";
			}
		} else {
			my $SIOCGIFHWADDR= 0x8927;     # man 2 ioctl_list

			# A configured MAC Address should always override a guessed value
			if ($client_mac_address and length($client_mac_address) > 0 and not($client_mac_address eq "00:00:00:00:00:00")) {
				$result= $client_mac_address;
			}
			else {
				socket SOCKET, PF_INET, SOCK_DGRAM, getprotobyname('ip')
					or die "socket: $!";

				if(ioctl SOCKET, $SIOCGIFHWADDR, $ifreq) {
					my ($if, $mac)= unpack 'h36 H12', $ifreq;

					if (length($mac) > 0) {
						$mac=~ m/^([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/;
						$mac= sprintf("%s:%s:%s:%s:%s:%s", $1, $2, $3, $4, $5, $6);
						$result = $mac;
					}
				}
			}
		}
	}
	return $result;
}


#===  FUNCTION  ================================================================
#         NAME:  get_interface_for_ip
#   PARAMETERS:  ip address (i.e. 192.168.0.1)
#      RETURNS:  array: list of interfaces if ip=0.0.0.0, matching interface if found, undef else
#  DESCRIPTION:  Uses proc fs (/proc/net/dev) to get list of interfaces.
#===============================================================================
sub get_interface_for_ip {
    my $result;
    my $ip= shift;
    if ($ip && length($ip) > 0) {
        my @ifs= &get_interfaces();
        if($ip eq "0.0.0.0") {
            $result = "all";
        } else {
            foreach (@ifs) {
                my $if=$_;
                if(get_ip($if) eq $ip) {
                    $result = $if;
                    last;
                }
            }       
        }
    }       
    return $result;
}


#===  FUNCTION  ================================================================
#         NAME:  get_ip 
#   PARAMETERS:  interface name (i.e. eth0)
#      RETURNS:  (ip address) 
#  DESCRIPTION:  Uses ioctl to get ip address directly from system.
#===============================================================================
sub get_ip {
    my $ifreq= shift;
    my $result= "";
    my $SIOCGIFADDR= 0x8915;       # man 2 ioctl_list
        my $proto= getprotobyname('ip');

    socket SOCKET, PF_INET, SOCK_DGRAM, $proto
        or die "socket: $!";

    if(ioctl SOCKET, $SIOCGIFADDR, $ifreq) {
        my ($if, $sin)    = unpack 'a16 a16', $ifreq;
        my ($port, $addr) = sockaddr_in $sin;
        my $ip            = inet_ntoa $addr;

        if ($ip && length($ip) > 0) {
            $result = $ip;
        }
    }

    return $result;
}


#===  FUNCTION  ================================================================
#         NAME:  get_local_mac_for_remote_ip
#   PARAMETERS:  none (takes server_ip from global variable)
#      RETURNS:  (ip address from interface that is used for communication) 
#  DESCRIPTION:  Uses ioctl to get routing table from system, checks which entry
#                matches (defaultroute last).
#===============================================================================
sub get_local_mac_for_remote_ip {
	my $server_ip= shift;
	my $result= "00:00:00:00:00:00";

	if($server_ip =~ /^(\d\d?\d?\.){3}\d\d?\d?$/) {
		my $PROC_NET_ROUTE= ('/proc/net/route');

		open(PROC_NET_ROUTE, "<$PROC_NET_ROUTE")
			or die "Could not open $PROC_NET_ROUTE";

		my @ifs = <PROC_NET_ROUTE>;

		close(PROC_NET_ROUTE);

		# Eat header line
		shift @ifs;
		chomp @ifs;
		foreach my $line(@ifs) {
			my ($Iface,$Destination,$Gateway,$Flags,$RefCnt,$Use,$Metric,$Mask,$MTU,$Window,$IRTT)=split(/\s/, $line);
			my $destination;
			my $mask;
			my ($d,$c,$b,$a)=unpack('a2 a2 a2 a2', $Destination);
			$destination= sprintf("%d.%d.%d.%d", hex($a), hex($b), hex($c), hex($d));
			($d,$c,$b,$a)=unpack('a2 a2 a2 a2', $Mask);
			$mask= sprintf("%d.%d.%d.%d", hex($a), hex($b), hex($c), hex($d));
			if(new NetAddr::IP($server_ip)->within(new NetAddr::IP($destination, $mask))) {
				# destination matches route, save mac and exit
				$result= &get_mac($Iface);
				last;
			}
		}
	} else {
		daemon_log("get_local_mac_for_remote_ip was called with a non-ip parameter: $server_ip", 1);
	}
	return $result;
}

sub get_local_ip_for_remote_ip {
	my $server_ip= shift;
	my $result="0.0.0.0";

	if($server_ip =~ /^(\d\d?\d?\.){3}\d\d?\d?$/) {
		if($server_ip eq "127.0.0.1") {
			$result="127.0.0.1";
		} else {
			my $PROC_NET_ROUTE= ('/proc/net/route');

			open(PROC_NET_ROUTE, "<$PROC_NET_ROUTE")
				or die "Could not open $PROC_NET_ROUTE";

			my @ifs = <PROC_NET_ROUTE>;

			close(PROC_NET_ROUTE);

			# Eat header line
			shift @ifs;
			chomp @ifs;
			foreach my $line(@ifs) {
				my ($Iface,$Destination,$Gateway,$Flags,$RefCnt,$Use,$Metric,$Mask,$MTU,$Window,$IRTT)=split(/\s/, $line);
				my $destination;
				my $mask;
				my ($d,$c,$b,$a)=unpack('a2 a2 a2 a2', $Destination);
				$destination= sprintf("%d.%d.%d.%d", hex($a), hex($b), hex($c), hex($d));
				($d,$c,$b,$a)=unpack('a2 a2 a2 a2', $Mask);
				$mask= sprintf("%d.%d.%d.%d", hex($a), hex($b), hex($c), hex($d));
				if(new NetAddr::IP($server_ip)->within(new NetAddr::IP($destination, $mask))) {
					# destination matches route, save mac and exit
					$result= &get_ip($Iface);
					last;
				}
			}
		}
	} else {
		daemon_log("get_local_ip_for_remote_ip was called with a non-ip parameter: $server_ip", 1);
	}
	return $result;
}


sub generate_hw_digest {
	my $hw_data;
	foreach my $line (split /\n/, `cat /proc/bus/pci/devices`) {
		$hw_data.= sprintf "%s", $line =~ /[^\s]+\s([^\s]+)\s.*/;
	}
	return(md5_base64($hw_data));
}


sub create_passwd {
    my $new_passwd = "";
    for(my $i=0; $i<31; $i++) {
        $new_passwd .= ("a".."z","A".."Z",0..9)[int(rand(62))]
    }

    return $new_passwd;
}


sub create_ciphering {
    my ($passwd) = @_;
	if((!defined($passwd)) || length($passwd)==0) {
		$passwd = "";
	}
    $passwd = substr(md5_hex("$passwd") x 32, 0, 32);
    my $iv = substr(md5_hex('GONICUS GmbH'),0, 16);
    my $my_cipher = Crypt::Rijndael->new($passwd , Crypt::Rijndael::MODE_CBC());
    $my_cipher->set_iv($iv);
    return $my_cipher;
}


sub encrypt_msg {
    my ($msg, $key) = @_;
    my $my_cipher = &create_ciphering($key);
    {
      use bytes;
      $msg = "\0"x(16-length($msg)%16).$msg;
    }
    $msg = $my_cipher->encrypt($msg);
    chomp($msg = &encode_base64($msg));
    # there are no newlines allowed inside msg
    $msg=~ s/\n//g;
    return $msg;
}


sub decrypt_msg {

    my ($msg, $key) = @_ ;
    $msg = &decode_base64($msg);
    my $my_cipher = &create_ciphering($key);
    $msg = $my_cipher->decrypt($msg); 
    $msg =~ s/\0*//g;
    return $msg;
}


sub get_server_addresses {
    my $domain= shift;
    my @result;
 
    my $error = 0;
    my $res   = Net::DNS::Resolver->new;
    my $query = $res->send("_gosa-si._tcp.".$domain, "SRV");
    my @hits;

    if ($query) {
        foreach my $rr ($query->answer) {
            push(@hits, $rr->target.":".$rr->port);
        }
    }
    else {
        #warn "query failed: ", $res->errorstring, "\n";
        $error++;
    }

    if( $error == 0 ) {
        foreach my $hit (@hits) {
            my ($hit_name, $hit_port) = split(/:/, $hit);
			chomp($hit_name);
			chomp($hit_port);

            my $address_query = $res->send($hit_name);
            if( 1 == length($address_query->answer) ) {
                foreach my $rr ($address_query->answer) {
                    push(@result, $rr->address.":".$hit_port);
                }
            }
        }
    }

#    my $dig_cmd= 'dig +nocomments srv _gosa-si._tcp.'.$domain;
#
#    my $output= `$dig_cmd 2>&1`;
#    open (PIPE, "$dig_cmd 2>&1 |");
#    while(<PIPE>) {
#        chomp $_;
#        # If it's not a comment
#        if($_ =~ m/^[^;]/) {
#            my @matches= split /\s+/;
#
#            # Push hostname with port
#            if($matches[3] eq 'SRV') {
#                push @result, $matches[7].':'.$matches[6];
#            } elsif ($matches[3] eq 'A') {
#                my $i=0;
#
#                # Substitute the hostname with the ip address of the matching A record
#                foreach my $host (@result) {
#                    if ((split /\:/, $host)[0] eq $matches[0]) {
#                        $result[$i]= $matches[4].':'.(split /\:/, $host)[1];
#                    }
#                    $i++;
#                }
#            }
#        }
#    }
#    close(PIPE);
    return @result;
}


##===  FUNCTION  ================================================================
##         NAME:  create_ciphering
##   PARAMETERS:  passwd - string - used to create ciphering
##      RETURNS:  cipher - object
##  DESCRIPTION:  creates a Crypt::Rijndael::MODE_CBC object with passwd as key
##===============================================================================
#sub create_ciphering {
#    my ($passwd) = @_;
#    $passwd = substr(md5_hex("$passwd") x 32, 0, 32);
#    my $iv = substr(md5_hex('GONICUS GmbH'),0, 16);
#
#    #daemon_log("iv: $iv", 7);
#    #daemon_log("key: $passwd", 7);
#    my $my_cipher = Crypt::Rijndael->new($passwd , Crypt::Rijndael::MODE_CBC());
#    $my_cipher->set_iv($iv);
#    return $my_cipher;
#}
#
#
#sub create_ciphering {
#    my ($passwd) = @_;
#    $passwd = substr(md5_hex("$passwd") x 32, 0, 32);
#    my $iv = substr(md5_hex('GONICUS GmbH'),0, 16);
#    my $my_cipher = Crypt::Rijndael->new($passwd , Crypt::Rijndael::MODE_CBC());
#    $my_cipher->set_iv($iv);
#    return $my_cipher;
#}
#
#
#sub encrypt_msg {
#    my ($msg, $key) = @_;
#    my $my_cipher = &create_ciphering($key);
#    {
#      use bytes;
#      $msg = "\0"x(16-length($msg)%16).$msg;
#    }
#    $msg = $my_cipher->encrypt($msg);
#    chomp($msg = &encode_base64($msg));
#    # there are no newlines allowed inside msg
#    $msg=~ s/\n//g;
#    return $msg;
#}
#
#
#sub decrypt_msg {
#    my ($msg, $key) = @_ ;
#    $msg = &decode_base64($msg);
#    my $my_cipher = &create_ciphering($key);
#    $msg = $my_cipher->decrypt($msg); 
#    $msg =~ s/\0*//g;
#    return $msg;
#}


#===  FUNCTION  ================================================================
#         NAME:  send_msg_hash_to_target
#   PARAMETERS:  msg_hash - hash - xml_hash created with function create_xml_hash
#                PeerAddr string - socket address to send msg
#                PeerPort string - socket port, if not included in socket address
#      RETURNS:  nothing
#  DESCRIPTION:  ????
#===============================================================================
sub send_msg_hash_to_target {
    my ($msg_hash, $address, $encrypt_key) = @_ ;
    my $msg = &create_xml_string($msg_hash);
    my $header = @{$msg_hash->{'header'}}[0];
    my $error = &send_msg_to_target($msg, $address, $encrypt_key, $header);
    
    return $error;
}


sub send_msg_to_target {
    my ($msg, $address, $encrypt_key, $msg_header) = @_ ;
    my $error = 0;

    if( $msg_header ) {
        $msg_header = "'$msg_header'-";
    }
    else {
        $msg_header = "";
    }

    # encrypt xml msg
    my $crypted_msg = &encrypt_msg($msg, $encrypt_key);

    # opensocket
    my $socket = &open_socket($address);
    if( !$socket ) {
        daemon_log("cannot send ".$msg_header."msg to $address , host not reachable", 1);
        $error++;
    }
    
    if( $error == 0 ) {
        # send xml msg
        print $socket $crypted_msg."\n";

        daemon_log("send ".$msg_header."msg to $address", 1);
        daemon_log("message:\n$msg", 8);

    }

    # close socket in any case
    if( $socket ) {
        close $socket;
    }

    return $error;
}


sub write_to_file {
    my ($string, $file) = @_;
    my $error = 0;

    if( not defined $file || not -f $file ) {
        &main::daemon_log("ERROR: $prg: check '-f file' failed: $file", 1);
        $error++;
    }
    if( not defined $string || 0 == length($string)) {
        &main::daemon_log("ERROR: $prg: empty string to write to file '$file'", 1);
        $error++;
    }
    
    if( $error == 0 ) {

        chomp($string);
    
        open(FILE, ">> $file");
        print FILE $string."\n";
        close(FILE);
    }

    return;    
}


sub open_socket {
    my ($PeerAddr, $PeerPort) = @_ ;
    if(defined($PeerPort)){
        $PeerAddr = $PeerAddr.":".$PeerPort;
    }
    my $socket;
    $socket = new IO::Socket::INET(PeerAddr => $PeerAddr,
            Porto => "tcp",
            Type => SOCK_STREAM,
            Timeout => 5,
            );
    if(not defined $socket) {
        return;
    }
    &daemon_log("open_socket: $PeerAddr", 7);
    return $socket;
}


#===  FUNCTION  ================================================================
#         NAME:  register_at_server
#   PARAMETERS:  
#      RETURNS:  
#  DESCRIPTION:  
#===============================================================================
sub register_at_gosa_si_server {
    my ($kernel) = $_[KERNEL];
    my $try_to_register = 0;

    if( not $REGISTERED ) {
        # create new passwd and ciphering object for client-server communication
        $server_key = &create_passwd();

        my $events = join( ", ", keys %{$event_hash} );
        while(1) {

            if( $try_to_register >= @servers )  {
                last;
            }

            # fetch first gosa-si-server from @servers
            my $server = shift(@servers);

            # append shifted gosa-si-server at the end of @servers, so looking for servers never stop if
            # a registration never occured
            push( @servers, $server );
		
			# Check if our ip is resolvable - if not: don't try to register
			my $ip= &get_local_ip_for_remote_ip(sprintf("%s", $server =~ /^([0-9\.]*?):.*$/));
			my $resolver= Net::DNS::Resolver->new;
			my $dnsresult= $resolver->search($ip);
			my $dnsname="";
			if(!defined($dnsresult)) {
				&write_to_file("goto-error-dns:$ip", $fai_logpath);
				exit(1);
			} else {
				$dnsname=$dnsresult->{answer}[0]->{ptrdname};
			}

            # create registration msg
            my $local_ip = &get_local_ip_for_remote_ip(sprintf("%s", $server =~ /^([0-9\.]*?):.*$/));
            my $local_mac = &get_local_mac_for_remote_ip(sprintf("%s", $server =~ /^([0-9\.]*?):.*$/));
            my $register_hash = &create_xml_hash("here_i_am", $local_ip.":".$client_port, $server);
            &add_content2xml_hash($register_hash, "new_passwd", $server_key);
			&add_content2xml_hash($register_hash, "mac_address", $local_mac);
            &add_content2xml_hash($register_hash, "events", $events);
            &add_content2xml_hash($register_hash, "gotoHardwareChecksum", $gotoHardwareChecksum);

            # send xml hash to server with general server passwd
            my $res = &send_msg_hash_to_target($register_hash, $server, $default_server_key);
			if($res == 0) {
                # reset try_to_register
                $try_to_register = 0;
    
				# Set fixed client address
				$client_ip= &get_local_ip_for_remote_ip(sprintf("%s", $server =~ /^([0-9\.]*?):.*$/));
				$client_address= "$client_ip:$client_port";

				# Write the MAC address to file
				if(stat($opts_file)) {
					unlink($opts_file);
				}
				my $opts_file_FH;
				my $hostname= $dnsname;
				$hostname =~ s/\..*$//;
				open($opts_file_FH, ">$opts_file");
				print $opts_file_FH "MAC=\"$local_mac\"\n";
				print $opts_file_FH "IPADDRESS=\"$client_ip\"\n";
				print $opts_file_FH "HOSTNAME=\"$hostname\"\n";
				print $opts_file_FH "FQDN=\"$dnsname\"\n";
				close($opts_file_FH);
				last;
			} else {
                $try_to_register++;
                # wait 1 sec until trying to register again
                sleep(1);
				next;
			}
        }

        if( $try_to_register >= @servers )  {
            &write_to_file("gosa-si-no-server-available", $fai_logpath);
             $kernel->delay_set('register_at_gosa_si_server', $delay_set_time);
        } 
        else {
            daemon_log("waiting for msg 'register_at_gosa_si_server'",1);
            $kernel->delay_set('register_at_gosa_si_server', $delay_set_time);
            # clear old settings and set it again
            $kernel->delay_set('trigger_new_key', $server_key_lifetime);
        }
    }
    return;
}
    

sub check_key_and_xml_validity {
    my ($crypted_msg, $module_key) = @_;

    my $msg;
    my $msg_hash;
    eval{
        $msg = &decrypt_msg($crypted_msg, $module_key);
        &main::daemon_log("decrypted_msg: \n$msg", 8);

        $msg_hash = $xml->XMLin($msg, ForceArray=>1);

        ##############
        # check header
        my $header_l = $msg_hash->{'header'};
        if( 1 != @{$header_l} ) {
            die 'no or more headers specified';
        }
        my $header = @{$header_l}[0];
        if( 0 == length $header) {
            die 'header has length 0';
        }

        ##############
        # check source
        my $source_l = $msg_hash->{'source'};
        if( 1 != @{$source_l} ) {
            die 'no or more than 1 sources specified';
        }
        my $source = @{$source_l}[0];
        if( 0 == length $source) {
            die 'source has length 0';
        }
        unless( $source =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/ ) {
            die "source '$source' is neither a complete ip-address with port nor 'GOSA'";
        }
        
        ##############
        # check target  
        my $target_l = $msg_hash->{'target'};
        if( 1 != @{$target_l} ) {
            die 'no or more than 1 targets specified ';
        }
        my $target = @{$target_l}[0];
        if( 0 == length $target) {
            die 'target has length 0 ';
        }
        unless( $target =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/ ){
            die "source is neither a complete ip-address with port nor 'GOSA'";
        }
    };
    if($@) {
        &main::daemon_log("WARNING: do not understand the message or msg is not gosa-si envelope conform:", 5);
        &main::daemon_log("$@", 8);
        $msg = undef;
        $msg_hash = undef;
    }

    return ($msg, $msg_hash);
}


sub check_outgoing_xml_validity {
    my ($msg) = @_;

    my $msg_hash;
    eval{
        $msg_hash = $xml->XMLin($msg, ForceArray=>1);

        ##############
        # check header
        my $header_l = $msg_hash->{'header'};
        if( 1 != @{$header_l} ) {
            die 'no or more than one headers specified';
        }
        my $header = @{$header_l}[0];
        if( 0 == length $header) {
            die 'header has length 0';
        }

        ##############
        # check source
        my $source_l = $msg_hash->{'source'};
        if( 1 != @{$source_l} ) {
            die 'no or more than 1 sources specified';
        }
        my $source = @{$source_l}[0];
        if( 0 == length $source) {
            die 'source has length 0';
        }
        unless( $source =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/ ||
                $source =~ /^GOSA$/i ) {
            die "source '$source' is neither a complete ip-address with port";
        }
        
        ##############
        # check target  
        my $target_l = $msg_hash->{'target'};
        if( 1 != @{$target_l} ) {
            die "no or more than one targets specified";
        }
        foreach my $target (@$target_l) {
            if( 0 == length $target) {
                die "target has length 0";
            }
            unless( $target =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/ ) {
                die "target '$target' is not a complete ip-address with port or a valid target name";
            }
        }
    };
    if($@) {
        daemon_log("WARNING: outgoing msg is not gosa-si envelope conform", 5);
        daemon_log("$@ $msg", 8);
        $msg_hash = undef;
    }
    return ($msg_hash);
}


sub import_events {

    if (not -e $event_dir) {
        daemon_log("ERROR: cannot find directory or directory is not readable: $event_dir", 1);   
    }
    opendir (DIR, $event_dir) or die "ERROR while loading gosa-si-events from directory $event_dir : $!\n";

    while (defined (my $event = readdir (DIR))) {
        if( $event eq "." || $event eq ".." ) { next; }    

        eval{ require $event; };
        if( $@ ) {
            daemon_log("ERROR: import of event module '$event' failed", 1);
            daemon_log("$@", 8);
            next;
        }

        $event =~ /(\S*?).pm$/;
        my $event_module = $1;
        my $events_l = eval( $1."::get_events()") ;
        foreach my $event_name (@{$events_l}) {
            $event_hash->{$event_name} = $event_module;
        }

    }

    my @all_events = keys %$event_hash;
    my $all_events_string = join(", ", @all_events);
    
    daemon_log("INFO: imported events: $all_events_string", 5);
}

sub trigger_new_key {
    my ($kernel) = $_[KERNEL] ;   

    my $msg = "<xml><header>new_key</header><source>$client_address</source><target>$client_address</target></xml>";
    &send_msg_to_target($msg, $client_address, $server_key, 'new_key');

    $kernel->delay_set('trigger_new_key', $server_key_lifetime);

}


sub generic_file_reset {
    my ( $heap, $wheel_id ) = @_[ HEAP, ARG0 ];

    my $service = $heap->{services}->{$wheel_id};
    daemon_log("INFO: '$service' watching reset", 5);
    return;
}

sub generic_file_error {
    my ( $heap, $operation, $errno, $error_string, $wheel_id ) =
      @_[ HEAP, ARG0, ARG1, ARG2, ARG3 ];

    my $service = $heap->{services}->{$wheel_id};
    daemon_log("ERROR: '$service' watcher $operation error $errno: $error_string", 1);
    daemon_log("ERROR: shutting down '$service' file watcher", 1);

    delete $heap->{services}->{$wheel_id};
    delete $heap->{watchers}->{$wheel_id};
    return;
}

sub fifo_got_record {
    my $file_record = $_[ARG0];
    my $header;
    my $content = "";

    $file_record =~ /^(\S+)[ ]?([\s\S]+)?$/;
    if( defined $1 ) {
        $header = $1;
    } else {
        return;
    }

    if( defined $2 ) {
        $content = $2;
    }

    my $clmsg_hash = &create_xml_hash("CLMSG_$header", $client_address, $server_address, $content);
    &add_content2xml_hash($clmsg_hash, "macaddress", $client_mac_address);
    my $clmsg = &create_xml_string($clmsg_hash);
    &send_msg_to_target($clmsg, $server_address, $server_key);
    return;
}


sub _start {
    my ($kernel, $heap) = @_[KERNEL, HEAP];
    $kernel->alias_set('client_session');
    
    # force a registration at a gosa-si-server
    $kernel->yield('register_at_gosa_si_server');
    
    # install all file watcher defined
    while( my($file_name, $file) = each %files_to_watch ) {
        my $file_watcher = POE::Wheel::FollowTail->new(
            Filename   => $file,
            InputEvent => $file_name."_record",
            ResetEvent => "file_reset",
            ErrorEvent => "file_error",
            );
        $heap->{services}->{ $file_watcher->ID } = $file_name;
        $heap->{watchers}->{ $file_watcher->ID } = $file_watcher;
    }
}


sub server_input {
    my ($kernel, $heap, $input, $wheel) = @_[KERNEL, HEAP, ARG0, ARG1];
    my $error = 0;
    my $answer;
    
    daemon_log("Incoming msg:\n$input\n", 8);

    my ($msg, $msg_hash) = &check_key_and_xml_validity($input, $server_key);
    if( (!$msg) || (!$msg_hash) ) {
        daemon_log("Deciphering of incoming msg failed", 5);
        $error++;
    }


    ######################
    # process incoming msg
    if( $error == 0 ) {
        my $header = @{$msg_hash->{header}}[0];
        my $source = @{$msg_hash->{source}}[0];

        if( exists $event_hash->{$header} ) {
            # a event exists with the header as name
            daemon_log("found event '$header' at event-module '".$event_hash->{$header}."'", 5);
            no strict 'refs';
            $answer = &{$event_hash->{$header}."::$header"}($msg, $msg_hash);
        }
        else {
            daemon_log("WARNING: no event '$header' found in event modules under $event_dir", 1);
        }
    }

    ########
    # answer
    if( $answer ) {

        #check gosa-si envelope validity
        my $answer_hash = &check_outgoing_xml_validity($answer);

        if( $answer_hash ) {
            # answer is valid            

            # preprocessing
            if( $answer =~ "<header>registered</header>") {
                # set registered flag to true to stop sending further registered msgs
                $REGISTERED = 1;
            } 
            else {
                &send_msg_to_target($answer, $server_address, $server_key);
            }

            # postprocessing
            if( $answer =~ "<header>new_key</header>") {
                # set new key to global variable
                $answer =~ /<new_key>(\S*?)<\/new_key>/;
                my $new_key = $1;
                $server_key = $new_key;
            }
        }

    }

    return;
}

sub get_dns_domains() {
        my $line;
        my @searches;
        open(RESOLV, "</etc/resolv.conf");
        while(<RESOLV>){
                $line= $_;
                chomp $line;
                $line =~ s/^\s+//;
                $line =~ s/\s+$//;
                $line =~ s/\s+/ /;
                if ($line =~ /^domain (.*)$/ ){
                        push(@searches, $1);
                } elsif ($line =~ /^search (.*)$/ ){
                        push(@searches, split(/ /, $1));
                }
        }
        close(RESOLV);

        my %tmp = map { $_ => 1 } @searches;
        @searches = sort keys %tmp;

        return @searches;
}

#==== MAIN = main ==============================================================
#  parse commandline options
Getopt::Long::Configure( "bundling" );
GetOptions("h|help" => \&usage,
           "c|config=s" => \$cfg_file,
           "f|foreground" => \$foreground,
           "v|verbose+" => \$verbose,
           );

#  read and set config parameters
&check_cmdline_param ;
&read_configfile($cfg_file, %cfg_defaults);
&check_pid;


# forward error messages to logfile
if ( ! $foreground ) {
	open STDIN, '/dev/null' or die "Canâ€™t read /dev/null: $!";
	open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!";
	open STDERR, '>>/dev/null' or die "Can't write to /dev/null: $!";
}

# Just fork, if we are not in foreground mode
if( ! $foreground ) { 
    chdir '/'                 or die "Can't chdir to /: $!";
    $pid = fork;
    setsid                    or die "Can't start a new session: $!";
    umask 0;
} 
else { 
    $pid = $$; 
}

# Do something useful - put our PID into the pid_file
if( 0 != $pid ) {
    open( LOCK_FILE, ">$pid_file" );
    print LOCK_FILE "$pid\n";
    close( LOCK_FILE );
    if( !$foreground ) { 
        exit( 0 ) 
    };
}

daemon_log(" ", 1);
daemon_log("$prg started!", 1);

# delete old DBsqlite lock files
system('rm -f /tmp/gosa_si_lock*gosa-si-client*');

# detect ip and mac address and complete host address
#if( inet_aton($client_ip) ){ 
#print STDERR "ip: $client_ip\n";
#    $client_ip = inet_ntoa(inet_aton($client_ip)); 
#print STDERR "ip: $client_ip\n";
#} 
$client_address = $client_ip.":".$client_port;
my $network_interface= &get_interface_for_ip($client_ip);
$client_mac_address= &get_mac($network_interface);
daemon_log("gosa-si-client ip address detected: $client_ip", 1);
daemon_log("gosa-si-client mac address detected: $client_mac_address", 1);


# import events
&import_events();


# compute hardware checksum
$gotoHardwareChecksum= &generate_hw_digest();
daemon_log("gosa-si-client gotoHardwareChecksum detected: $gotoHardwareChecksum", 1);


# create socket for incoming xml messages
POE::Component::Server::TCP->new(
    Alias => 'gosa-si-client',
	Port => $client_port,
	ClientInput => \&server_input,
);
daemon_log("start socket for incoming xml messages at port '$client_port' ", 1);


# prepare variables
if( inet_aton($server_ip) ){ $server_ip = inet_ntoa(inet_aton($server_ip)); }
############################################################
# to change
if( $server_ip eq "127.0.1.1" ) { $server_ip = "127.0.0.1" } 
############################################################
if (defined $server_ip && defined $server_port) {
    $server_address = $server_ip.":".$server_port;
}
$xml = new XML::Simple();
$default_server_key = $server_key;


# add gosa-si-server address from config file at first position of server list
my $server_check_cfg = Config::IniFiles->new( -file => $cfg_file );
my $server_check = $server_check_cfg->val( "server", "ip");
if( defined $server_check ) {
	unshift(@servers, $server_address);
	my $servers_string = join(", ", @servers);
	daemon_log("INFO: found servers in configuration file: $servers_string", 5);
} else {
	my @tmp_servers;
	if ( !$server_domain) {
		# Try our DNS Searchlist
		for my $domain(get_dns_domains()) {
			chomp($domain);
			my @tmp_domains= &get_server_addresses($domain);
			if(@tmp_domains) {
				for my $tmp_server(@tmp_domains) {
					push @tmp_servers, $tmp_server;
				}
			}
		}
		if(@tmp_servers && length(@tmp_servers)==0) {
			daemon_log("ERROR: please specify a gosa-si-server address or a domain in config file", 1);
			kill 2, $$;
		}
	} else {
		@tmp_servers = &get_server_addresses($server_domain);
		if( 0 == @tmp_servers ) {
			daemon_log("ERROR: no gosa-si-server found in DNS for domain '$server_domain'",1);
			daemon_log("ERROR: please specify a gosa-si-server address or a domain in config file", 1);
			kill 2, $$;
		} 
	}

    foreach my $server (@tmp_servers) { 
        unshift(@servers, $server); 
    }
    my $servers_string = join(", ", @servers);
    daemon_log("INFO: found servers in DNS: $servers_string", 5);
}


# open fifo for non-gosa-si-client-msgs to gosa-si-server
POSIX::mkfifo("$gosa_si_client_fifo", "0600");


POE::Session->create(
	inline_states => {
		_start => \&_start, 
        register_at_gosa_si_server => \&register_at_gosa_si_server,
        trigger_new_key => \&trigger_new_key,
        
        # handle records from each defined file differently
        fifo_record => \&fifo_got_record,

        # handle file resets and errors the same way for each file
        file_reset => \&generic_file_reset,
        file_error => \&generic_file_error,
	}
);

POE::Kernel->run();
exit;

